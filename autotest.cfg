#预处理变量:
#使用'{}'扩起来的变量将在读取阶段自动替换成global节点或当前节点已存在的变量

#特殊变量:特殊变量使用"$xx$"括起来
#sublog:当前work的log文件夹,比如:"./log_root/[hash]/work1",由脚本在运行时替换
#如果是pre-work或者post-work,则sublog代表当前commit的log文件夹,比如"./log_root/[hash]"

#注意:节点和变量均不可大写

[global]
#仓库路径
repo_url = https://github.com/tastynoob/ritter-soc.git
#指定分支
repo_branch = master
#工作路径
working_dir = ./ritter
#log_root路径
log_root = ./logout

#true|false,启用时,将邮件信息使用print输出而不发送邮件
#在测试命令验证完毕前,先开启debug模式
debug_mode = true
#下面是自定义的变量
xiangshan_home = {working_dir}
nemu_home = ./nemu
am_home = ./nexus-am

#每次迭代开始都会重新拉取远程的最新commit并依次测试新增添的commit
[iteration]
#迭代次数,-1为无穷循环
num = 1
#每次迭代结束进行延迟,单位秒,可以使用数学表达式
end_delay=1*60
#执行任务过程中遇到错误进行的处理方式:
#stop:立即停止当前commit测试,中断程序
#skip:跳过当前迭代测试进入下次迭代
#ignore:忽略当前commit测试的错误,进入下一个commit测试
except_mode = stop

[pull]
#拉取前n个commit进行测试
n = 5

[mail]
#是否启用邮件发送
enable = true
mail_host = smtp.163.com
mail_sender = user@163.com
mail_license = ******
#收件人,可以使用';'分开表示多位收件人
mail_receivers = user1@163.com;user2@163.com 


#任务执行顺序
#work-pre->works-xxx->work-post->delay
#如果works-xxx发生错误,则视work-post执行失败,会执行work-post.except-task


#每次迭代开始前则执行该任务,pre-work没有post-task
[pre-work]
#pre-task执行错误会直接忽略
pre-task = echo startCycle
task =
#如果task执行错误则运行except-task
except-task = echo 'a cycle initialization error!'

#每次迭代完毕则执行该任务,post-work没有pre-task
[post-work]
errbuffer= ./errbuffer
mkdir = \
    if [ ! -d "{errbuffer}" ]; then \
        mkdir {errbuffer}; \
    fi
task= 
#如果整个迭代过程没有发生错误,会执行post-task
post-task = echo endCycle
#在当前迭代的过程中发生了错误,最后都会执行该任务
#except-task的信息不会记录到log_file里,而是直接打印到stdout
except-task = {mkdir}; cp -r $sublog$ {errbuffer}; echo cycle error

#下面是自定义的work,必须以"work-"为前缀,均为并行执行
[work-helloworld]
arg0 = helloworld
#任务开始前预处理任务,可省略,pre-task运行错误会忽略
pre-task = echo start
#目的任务,不可省略
task = echo {arg0}
#任务结束后所执行的任务,可省略,如果task错误,则不会执行post-task而是执行except-task
post-task = echo end
#执行task时发生错误所执行的任务,可省略,当前work测试错误时运行
except-task = echo error!

[work-helloworld2]
arg0 = helloworld2
pre-task=
task = mkdir test
post-task = echo end
except-task= echo error!