#预处理变量:
#使用'{}'扩起来的变量将在读取阶段自动替换成global节点或当前节点已存在的变量

#特殊变量:特殊变量使用"$xx$"括起来
#sublog:当前work的log文件夹,比如:"./log_root/[hash]/work1",由脚本在运行时替换
#如果是pre-work或者post-work,则sublog代表当前commit的log文件夹,比如"./log_root/[hash]"
#tid:当前work所分配的线程id,比如最大线程5,tid=0~4中的任意一个,只能在work-xxx中使用
#binfile:single模式下,binfile指定待测试文件的完整路径名称
#numa:使用numactrl来对任务进行分配核,需要任务具有numacores变量,脚本会自动生成合适的numactrl参数,比如numa -m 0 -C 0-7

#注意:节点和变量均不可大写

[global]
#仓库路径
repo_url = https://github.com/tastynoob/QMXDOC.git
#指定分支
repo_branch = master
#true|false,启用时,将邮件信息使用print输出而不发送邮件
#在测试命令验证完毕前,先开启debug模式
debug_mode = true
home = ./workspace
#工作路径
working_dir = {home}/XiangShan
#log_root路径
log_root = {home}/log_root


#下面是自定义的变量
xiangshan_home = {working_dir}
nemu_home = /nfs/home/xuyan/project_temp/NEMU
am_home = /nfs/home/xuyan/faxiang/nexus-am
mkfile = {home}/test.mk
initfile = {home}/init.mk
mkarg = NOOP_HOME={xiangshan_home} AM_HOME={am_home} NEMU_HOME={nemu_home}

#每次迭代开始都会重新拉取远程的最新commit并依次测试新增添的commit
[iteration]
#拉取前n个commit
pull = 2
#工作模式:
#single:单work多文件,一个work中,可能存在不同的测试文件,可以使用$binfile$来让脚本自动分配测试文件
#比如有8个待测试文件,但是只有一个任务,则该任务会被调用8次
#multi:多work单文件,允许多个work存在,但是只针对一个文件进行测试,不可使用$binfile$变量
working_mode=single
#每次迭代所使用的最大线程数
#single模式下,会对一个work开启多个线程对不同文件进行才测试
#multi模式下,会开启多个线程对多个work同时进行测试
max_process=2
#迭代次数,-1为无穷循环
num = 1
#每次迭代结束进行延迟,单位秒,可以使用数学表达式
end_delay= 0
#执行任务过程中遇到错误进行的处理方式:
#stop:立即停止当前commit测试,中断程序
#skip:跳过当前迭代测试进入下次迭代
#ignore:忽略当前commit测试的错误,进入下一个commit测试
except_mode = stop

[mail]
#是否启用邮件发送,true|false
enable = false
mail_host = smtp.163.com
mail_sender = user@163.com
mail_license = ******
#收件人,可以使用';'分开表示多位收件人
mail_receivers = user1@163.com;user2@163.com 

#任务执行顺序
#pre-work->works-xxx->post-work->delay
#注意:由于多个命令使用';'分隔时,它只会判断最后一个命令是否执行正确,因此关键命令请放在最后面


#每次迭代开始前则执行该任务,pre-work没有post-task
[pre-work]
#开始迭代的预处理任务
pre-task = echo startCycle 
#开始迭代的任务
task = 
#在执行pre-task,task的任意时刻发生错误,则会直接中断并执行except-task
except-task = echo 'a cycle initialization error!'



#下面是自定义的work,必须以"work-"为前缀,均为并行执行
[work-helloworld]
#存放待测试文件的路径,用于single工作模式,必须使用glob匹配原则,多个路径可以使用";"分开,脚本会自动在提供的路径中搜索
#对于xiangshantest,如果指定了checkpoints.paths,则脚本会在该文件中读取每一行作为checkpoint的路径
#每个glob路径后可以带一个数字,代表分类级数,比如home/a/b/c.txt,c.txt被分类了3次(a/b/c),因此填3
#如果不带数字,则默认为1,即使用文件名作为分类
binpath = ./* 1
#需要分配的核,如果值小于等于0或删除该变量,则代表禁用numactl
numacores = 1
#任务开始前预处理任务,可省略
pre-task = 
#目的任务,不可省略
task = $numa$ echo $binfile$/$numa$
#任务结束后所执行的任务,可省略
post-task = 
#在执行pre-task,task,post-task的任意时刻发生错误,则会直接中断并执行except-task
except-task = echo error!


#下面是自定义的work,必须以"work-"为前缀,均为并行执行
[work-helloworld2]
#存放待测试文件的路径,用于single工作模式,必须使用glob匹配原则
binpath = ./* 1
#需要分配的核
numacores = 1
#任务开始前预处理任务,可省略
pre-task = 
#目的任务,不可省略
task = $numa$ echo $binfile$/$numa$
#任务结束后所执行的任务,可省略
post-task = 
#在执行pre-task,task,post-task的任意时刻发生错误,则会直接中断并执行except-task
except-task = echo error!

#每次迭代完毕则执行该任务,post-work没有pre-task
[post-work]
errbuffer= {log_root}/errbuffer
mkdir = \
    if [ ! -d "{errbuffer}" ]; then \
        mkdir {errbuffer}; \
    fi
task= 
post-task = echo endCycle
#在执行pre-work,work-xxx发生错误时,等待所有前置任务完毕,则会执行except-task
#或者在执行task,post-task发生错误时,则会直接中断并执行except-task
#except-task的信息不会记录到log_file里,而是直接打印到stdout
except-task = {mkdir}; cp -r $sublog$ {errbuffer}; echo cycle error